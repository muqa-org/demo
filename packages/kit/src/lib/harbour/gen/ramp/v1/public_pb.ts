// @generated by protoc-gen-es v1.8.0 with parameter "target=ts"
// @generated from file ramp/v1/public.proto (package ramp.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage
} from "@bufbuild/protobuf";
import {Message, proto3, protoInt64} from "@bufbuild/protobuf";

/**
 * @generated from enum ramp.v1.Ecosystem
 */
export enum Ecosystem {
  /**
   * @generated from enum value: ECOSYSTEM_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * any EVM compatible chain - addresses are expected to be the right-most 160 bits of the keccak256 hash of the public key
   *
   * @generated from enum value: ECOSYSTEM_ETHEREUM = 10;
   */
  ETHEREUM = 10,

  /**
   * any Cosmos ecosystem chain - addresses are expected to be compatible with the Cosmos SDK (such as 160 bit BECH32)
   *
   * @generated from enum value: ECOSYSTEM_COSMOS = 20;
   */
  COSMOS = 20,
}
// Retrieve enum metadata with: proto3.getEnumType(Ecosystem)
proto3.util.setEnumType(Ecosystem, "ramp.v1.Ecosystem", [
  { no: 0, name: "ECOSYSTEM_UNSPECIFIED" },
  { no: 10, name: "ECOSYSTEM_ETHEREUM" },
  { no: 20, name: "ECOSYSTEM_COSMOS" },
]);

/**
 * @generated from enum ramp.v1.Protocol
 */
export enum Protocol {
  /**
   * @generated from enum value: PROTOCOL_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: PROTOCOL_ETHEREUM = 10;
   */
  ETHEREUM = 10,

  /**
   * @generated from enum value: PROTOCOL_AVAX = 20;
   */
  AVAX = 20,

  /**
   * @generated from enum value: PROTOCOL_TERRA = 30;
   */
  TERRA = 30,

  /**
   * @generated from enum value: PROTOCOL_POLYGON = 40;
   */
  POLYGON = 40,

  /**
   * @generated from enum value: PROTOCOL_ALEPH_ZERO = 50;
   */
  ALEPH_ZERO = 50,
}
// Retrieve enum metadata with: proto3.getEnumType(Protocol)
proto3.util.setEnumType(Protocol, "ramp.v1.Protocol", [
  { no: 0, name: "PROTOCOL_UNSPECIFIED" },
  { no: 10, name: "PROTOCOL_ETHEREUM" },
  { no: 20, name: "PROTOCOL_AVAX" },
  { no: 30, name: "PROTOCOL_TERRA" },
  { no: 40, name: "PROTOCOL_POLYGON" },
  { no: 50, name: "PROTOCOL_ALEPH_ZERO" },
]);

/**
 * An AssetId helps the client to identify an exact token and customise the UI.
 * The AssetId is universal across all chains, in fact our responses always include the Network, and the AssetID.
 * So ASSET_ID_USDC will always be the official Circle USDC on any chain, be that Ethereum, or Avalanche, or Polygon.
 *
 * @generated from enum ramp.v1.AssetId
 */
export enum AssetId {
  /**
   * @generated from enum value: ASSET_ID_UNSPECIFIED = 0;
   */
  ASSET_ID_UNSPECIFIED = 0,

  /**
   * @generated from enum value: ASSET_ID_USDC = 10;
   */
  ASSET_ID_USDC = 10,

  /**
   * @generated from enum value: ASSET_ID_AXL_USDC = 20;
   */
  ASSET_ID_AXL_USDC = 20,

  /**
   * @generated from enum value: ASSET_ID_1USD = 30;
   */
  ASSET_ID_1USD = 30,
}
// Retrieve enum metadata with: proto3.getEnumType(AssetId)
proto3.util.setEnumType(AssetId, "ramp.v1.AssetId", [
  { no: 0, name: "ASSET_ID_UNSPECIFIED" },
  { no: 10, name: "ASSET_ID_USDC" },
  { no: 20, name: "ASSET_ID_AXL_USDC" },
  { no: 30, name: "ASSET_ID_1USD" },
]);

/**
 * @generated from enum ramp.v1.Network
 */
export enum Network {
  /**
   * @generated from enum value: NETWORK_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: NETWORK_ETHEREUM_MAINNET = 10;
   */
  ETHEREUM_MAINNET = 10,

  /**
   * @generated from enum value: NETWORK_ETHEREUM_SEPOLIA = 20;
   */
  ETHEREUM_SEPOLIA = 20,

  /**
   * @generated from enum value: NETWORK_AVAX_FUJI = 30;
   */
  AVAX_FUJI = 30,

  /**
   * @generated from enum value: NETWORK_AVAX_C_MAINNET = 40;
   */
  AVAX_C_MAINNET = 40,

  /**
   * @generated from enum value: NETWORK_TERRA2_MAINNET = 50;
   */
  TERRA2_MAINNET = 50,

  /**
   * @generated from enum value: NETWORK_POLYGON_MAINNET = 60;
   */
  POLYGON_MAINNET = 60,

  /**
   * @generated from enum value: NETWORK_POLYGON_AMOY = 70;
   */
  POLYGON_AMOY = 70,

  /**
   * @generated from enum value: NETWORK_ALEPH_ZERO_MAINNET = 80;
   */
  ALEPH_ZERO_MAINNET = 80,

  /**
   * @generated from enum value: NETWORK_ALEPH_ZERO_TESTNET = 90;
   */
  ALEPH_ZERO_TESTNET = 90,
}
// Retrieve enum metadata with: proto3.getEnumType(Network)
proto3.util.setEnumType(Network, "ramp.v1.Network", [
  { no: 0, name: "NETWORK_UNSPECIFIED" },
  { no: 10, name: "NETWORK_ETHEREUM_MAINNET" },
  { no: 20, name: "NETWORK_ETHEREUM_SEPOLIA" },
  { no: 30, name: "NETWORK_AVAX_FUJI" },
  { no: 40, name: "NETWORK_AVAX_C_MAINNET" },
  { no: 50, name: "NETWORK_TERRA2_MAINNET" },
  { no: 60, name: "NETWORK_POLYGON_MAINNET" },
  { no: 70, name: "NETWORK_POLYGON_AMOY" },
  { no: 80, name: "NETWORK_ALEPH_ZERO_MAINNET" },
  { no: 90, name: "NETWORK_ALEPH_ZERO_TESTNET" },
]);

/**
 * @generated from message ramp.v1.PingRequest
 */
export class PingRequest extends Message<PingRequest> {
  constructor(data?: PartialMessage<PingRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.PingRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PingRequest {
    return new PingRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PingRequest {
    return new PingRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PingRequest {
    return new PingRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PingRequest | PlainMessage<PingRequest> | undefined, b: PingRequest | PlainMessage<PingRequest> | undefined): boolean {
    return proto3.util.equals(PingRequest, a, b);
  }
}

/**
 * @generated from message ramp.v1.PingResponse
 */
export class PingResponse extends Message<PingResponse> {
  /**
   * @generated from field: string message = 10;
   */
  message = "";

  constructor(data?: PartialMessage<PingResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.PingResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PingResponse {
    return new PingResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PingResponse {
    return new PingResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PingResponse {
    return new PingResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PingResponse | PlainMessage<PingResponse> | undefined, b: PingResponse | PlainMessage<PingResponse> | undefined): boolean {
    return proto3.util.equals(PingResponse, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoRequest
 */
export class GetAccountInfoRequest extends Message<GetAccountInfoRequest> {
  constructor(data?: PartialMessage<GetAccountInfoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoRequest {
    return new GetAccountInfoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoRequest {
    return new GetAccountInfoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoRequest {
    return new GetAccountInfoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoRequest | PlainMessage<GetAccountInfoRequest> | undefined, b: GetAccountInfoRequest | PlainMessage<GetAccountInfoRequest> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoRequest, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse
 */
export class GetAccountInfoResponse extends Message<GetAccountInfoResponse> {
  /**
   * @generated from oneof ramp.v1.GetAccountInfoResponse.result
   */
  result: {
    /**
     * when result is authentication user needs to be onboarded or logged in
     *
     * @generated from field: ramp.v1.GetAccountInfoResponse.Authentication authentication = 20;
     */
    value: GetAccountInfoResponse_Authentication;
    case: "authentication";
  } | {
    /**
     * when result is account user is logged
     *
     * @generated from field: ramp.v1.GetAccountInfoResponse.Account account = 30;
     */
    value: GetAccountInfoResponse_Account;
    case: "account";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<GetAccountInfoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 20, name: "authentication", kind: "message", T: GetAccountInfoResponse_Authentication, oneof: "result" },
    { no: 30, name: "account", kind: "message", T: GetAccountInfoResponse_Account, oneof: "result" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse {
    return new GetAccountInfoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse {
    return new GetAccountInfoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse {
    return new GetAccountInfoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse | PlainMessage<GetAccountInfoResponse> | undefined, b: GetAccountInfoResponse | PlainMessage<GetAccountInfoResponse> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.Authentication
 */
export class GetAccountInfoResponse_Authentication extends Message<GetAccountInfoResponse_Authentication> {
  /**
   * authentication_url should be loaded in the i-frame or browser window in order to log in or onboard user
   *
   * @generated from field: string authentication_url = 10;
   */
  authenticationUrl = "";

  /**
   * token expiry in seconds, the frontend is expected to close the onboarding view (but the user can come back any time)
   * don't worry about the time skew from api latency, there's a grace period on top of this expiry
   *
   * @generated from field: int64 expires_in_sec = 20;
   */
  expiresInSec = protoInt64.zero;

  constructor(data?: PartialMessage<GetAccountInfoResponse_Authentication>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.Authentication";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "authentication_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "expires_in_sec", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_Authentication {
    return new GetAccountInfoResponse_Authentication().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Authentication {
    return new GetAccountInfoResponse_Authentication().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Authentication {
    return new GetAccountInfoResponse_Authentication().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_Authentication | PlainMessage<GetAccountInfoResponse_Authentication> | undefined, b: GetAccountInfoResponse_Authentication | PlainMessage<GetAccountInfoResponse_Authentication> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_Authentication, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.Account
 */
export class GetAccountInfoResponse_Account extends Message<GetAccountInfoResponse_Account> {
  /**
   * list of whitelisted addresses. On-ramping could be done only to whitelisted address
   *
   * @generated from field: repeated ramp.v1.GetAccountInfoResponse.Wallet wallets = 10;
   */
  wallets: GetAccountInfoResponse_Wallet[] = [];

  /**
   * A bank account created by Harbour in the name of the user, where funds can be sent
   *
   * @generated from oneof ramp.v1.GetAccountInfoResponse.Account.onramp_bank_account
   */
  onrampBankAccount: {
    /**
     * only for scheme SCAN (UK payments)
     *
     * @generated from field: ramp.v1.ScanCoordinates onramp_scan = 100;
     */
    value: ScanCoordinates;
    case: "onrampScan";
  } | {
    /**
     * for both SEPA and SWIFT schemes
     *
     * @generated from field: ramp.v1.IbanCoordinates onramp_iban = 110;
     */
    value: IbanCoordinates;
    case: "onrampIban";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * A bank account set by the user for off-ramping, see rpc SetBankAccount
   *
   * @generated from oneof ramp.v1.GetAccountInfoResponse.Account.offramp_bank_account
   */
  offrampBankAccount: {
    /**
     * only for scheme SCAN (UK payments)
     *
     * @generated from field: ramp.v1.ScanCoordinates offramp_scan = 200;
     */
    value: ScanCoordinates;
    case: "offrampScan";
  } | {
    /**
     * for both SEPA and SWIFT schemes
     *
     * @generated from field: ramp.v1.IbanCoordinates offramp_iban = 210;
     */
    value: IbanCoordinates;
    case: "offrampIban";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * account holder name for on and off-ramping
   *
   * @generated from field: string account_holder = 20;
   */
  accountHolder = "";

  /**
   * list of supported assets
   *
   * @generated from field: repeated ramp.v1.GetAccountInfoResponse.CryptoAsset crypto_assets = 30;
   */
  cryptoAssets: GetAccountInfoResponse_CryptoAsset[] = [];

  constructor(data?: PartialMessage<GetAccountInfoResponse_Account>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.Account";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "wallets", kind: "message", T: GetAccountInfoResponse_Wallet, repeated: true },
    { no: 100, name: "onramp_scan", kind: "message", T: ScanCoordinates, oneof: "onramp_bank_account" },
    { no: 110, name: "onramp_iban", kind: "message", T: IbanCoordinates, oneof: "onramp_bank_account" },
    { no: 200, name: "offramp_scan", kind: "message", T: ScanCoordinates, oneof: "offramp_bank_account" },
    { no: 210, name: "offramp_iban", kind: "message", T: IbanCoordinates, oneof: "offramp_bank_account" },
    { no: 20, name: "account_holder", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 30, name: "crypto_assets", kind: "message", T: GetAccountInfoResponse_CryptoAsset, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_Account {
    return new GetAccountInfoResponse_Account().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Account {
    return new GetAccountInfoResponse_Account().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Account {
    return new GetAccountInfoResponse_Account().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_Account | PlainMessage<GetAccountInfoResponse_Account> | undefined, b: GetAccountInfoResponse_Account | PlainMessage<GetAccountInfoResponse_Account> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_Account, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.CryptoAsset
 */
export class GetAccountInfoResponse_CryptoAsset extends Message<GetAccountInfoResponse_CryptoAsset> {
  /**
   * @generated from field: ramp.v1.Protocol protocol = 5;
   */
  protocol = Protocol.UNSPECIFIED;

  /**
   * @generated from field: ramp.v1.Network network = 10;
   */
  network = Network.UNSPECIFIED;

  /**
   * the client can use this to match an asset with precision and display custom wording / icon, e.g. "USDC"
   *
   * @generated from field: ramp.v1.AssetId asset_id = 20;
   */
  assetId = AssetId.ASSET_ID_UNSPECIFIED;

  /**
   * to be used as a fallback if the client doesn't recognise the asset_id (eg: out of date proto definitions)
   *
   * @generated from field: string short_name = 30;
   */
  shortName = "";

  /**
   * @generated from oneof ramp.v1.GetAccountInfoResponse.CryptoAsset.details
   */
  details: {
    /**
     * @generated from field: ramp.v1.GetAccountInfoResponse.CryptoAsset.EthereumErc20Token ethereum_erc20_token = 40;
     */
    value: GetAccountInfoResponse_CryptoAsset_EthereumErc20Token;
    case: "ethereumErc20Token";
  } | {
    /**
     * @generated from field: ramp.v1.GetAccountInfoResponse.CryptoAsset.CosmosIcs20Token cosmos_ics20_token = 50;
     */
    value: GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token;
    case: "cosmosIcs20Token";
  } | {
    /**
     * @generated from field: ramp.v1.GetAccountInfoResponse.CryptoAsset.SubstratePsp22Token substrate_psp22_token = 60;
     */
    value: GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token;
    case: "substratePsp22Token";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<GetAccountInfoResponse_CryptoAsset>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.CryptoAsset";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 5, name: "protocol", kind: "enum", T: proto3.getEnumType(Protocol) },
    { no: 10, name: "network", kind: "enum", T: proto3.getEnumType(Network) },
    { no: 20, name: "asset_id", kind: "enum", T: proto3.getEnumType(AssetId) },
    { no: 30, name: "short_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 40, name: "ethereum_erc20_token", kind: "message", T: GetAccountInfoResponse_CryptoAsset_EthereumErc20Token, oneof: "details" },
    { no: 50, name: "cosmos_ics20_token", kind: "message", T: GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token, oneof: "details" },
    { no: 60, name: "substrate_psp22_token", kind: "message", T: GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token, oneof: "details" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_CryptoAsset {
    return new GetAccountInfoResponse_CryptoAsset().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_CryptoAsset {
    return new GetAccountInfoResponse_CryptoAsset().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_CryptoAsset {
    return new GetAccountInfoResponse_CryptoAsset().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_CryptoAsset | PlainMessage<GetAccountInfoResponse_CryptoAsset> | undefined, b: GetAccountInfoResponse_CryptoAsset | PlainMessage<GetAccountInfoResponse_CryptoAsset> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_CryptoAsset, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.CryptoAsset.EthereumErc20Token
 */
export class GetAccountInfoResponse_CryptoAsset_EthereumErc20Token extends Message<GetAccountInfoResponse_CryptoAsset_EthereumErc20Token> {
  /**
   * ERC20 token address
   *
   * @generated from field: string token_address = 10;
   */
  tokenAddress = "";

  constructor(data?: PartialMessage<GetAccountInfoResponse_CryptoAsset_EthereumErc20Token>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.CryptoAsset.EthereumErc20Token";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "token_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_CryptoAsset_EthereumErc20Token {
    return new GetAccountInfoResponse_CryptoAsset_EthereumErc20Token().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_CryptoAsset_EthereumErc20Token {
    return new GetAccountInfoResponse_CryptoAsset_EthereumErc20Token().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_CryptoAsset_EthereumErc20Token {
    return new GetAccountInfoResponse_CryptoAsset_EthereumErc20Token().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_CryptoAsset_EthereumErc20Token | PlainMessage<GetAccountInfoResponse_CryptoAsset_EthereumErc20Token> | undefined, b: GetAccountInfoResponse_CryptoAsset_EthereumErc20Token | PlainMessage<GetAccountInfoResponse_CryptoAsset_EthereumErc20Token> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_CryptoAsset_EthereumErc20Token, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.CryptoAsset.CosmosIcs20Token
 */
export class GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token extends Message<GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token> {
  /**
   * IBC token address
   *
   * @generated from field: string ibc_address = 10;
   */
  ibcAddress = "";

  constructor(data?: PartialMessage<GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.CryptoAsset.CosmosIcs20Token";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "ibc_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token {
    return new GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token {
    return new GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token {
    return new GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token | PlainMessage<GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token> | undefined, b: GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token | PlainMessage<GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.CryptoAsset.SubstratePsp22Token
 */
export class GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token extends Message<GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token> {
  /**
   * Substrate PSP22 token address
   *
   * @generated from field: string token_address = 10;
   */
  tokenAddress = "";

  constructor(data?: PartialMessage<GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.CryptoAsset.SubstratePsp22Token";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "token_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token {
    return new GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token {
    return new GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token {
    return new GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token | PlainMessage<GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token> | undefined, b: GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token | PlainMessage<GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.Wallet
 */
export class GetAccountInfoResponse_Wallet extends Message<GetAccountInfoResponse_Wallet> {
  /**
   * user given name, less then 100 symbols
   *
   * @generated from field: string name = 5;
   */
  name = "";

  /**
   * @generated from field: ramp.v1.Protocol protocol = 10;
   */
  protocol = Protocol.UNSPECIFIED;

  /**
   * address of a wallet in blockchain
   *
   * @generated from field: string address = 20;
   */
  address = "";

  /**
   * assets available for on- and off- ramping
   *
   * @generated from field: repeated ramp.v1.GetAccountInfoResponse.Wallet.RampAsset assets = 30;
   */
  assets: GetAccountInfoResponse_Wallet_RampAsset[] = [];

  constructor(data?: PartialMessage<GetAccountInfoResponse_Wallet>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.Wallet";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 5, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "protocol", kind: "enum", T: proto3.getEnumType(Protocol) },
    { no: 20, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 30, name: "assets", kind: "message", T: GetAccountInfoResponse_Wallet_RampAsset, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_Wallet {
    return new GetAccountInfoResponse_Wallet().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Wallet {
    return new GetAccountInfoResponse_Wallet().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Wallet {
    return new GetAccountInfoResponse_Wallet().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_Wallet | PlainMessage<GetAccountInfoResponse_Wallet> | undefined, b: GetAccountInfoResponse_Wallet | PlainMessage<GetAccountInfoResponse_Wallet> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_Wallet, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.Wallet.RampAsset
 */
export class GetAccountInfoResponse_Wallet_RampAsset extends Message<GetAccountInfoResponse_Wallet_RampAsset> {
  /**
   * @generated from field: ramp.v1.GetAccountInfoResponse.CryptoAsset asset = 10;
   */
  asset?: GetAccountInfoResponse_CryptoAsset;

  /**
   * @generated from field: ramp.v1.GetAccountInfoResponse.Wallet.OnRamp on_ramp = 20;
   */
  onRamp?: GetAccountInfoResponse_Wallet_OnRamp;

  /**
   * @generated from field: ramp.v1.GetAccountInfoResponse.Wallet.OffRamp off_ramp = 30;
   */
  offRamp?: GetAccountInfoResponse_Wallet_OffRamp;

  constructor(data?: PartialMessage<GetAccountInfoResponse_Wallet_RampAsset>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.Wallet.RampAsset";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "asset", kind: "message", T: GetAccountInfoResponse_CryptoAsset },
    { no: 20, name: "on_ramp", kind: "message", T: GetAccountInfoResponse_Wallet_OnRamp },
    { no: 30, name: "off_ramp", kind: "message", T: GetAccountInfoResponse_Wallet_OffRamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_Wallet_RampAsset {
    return new GetAccountInfoResponse_Wallet_RampAsset().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Wallet_RampAsset {
    return new GetAccountInfoResponse_Wallet_RampAsset().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Wallet_RampAsset {
    return new GetAccountInfoResponse_Wallet_RampAsset().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_Wallet_RampAsset | PlainMessage<GetAccountInfoResponse_Wallet_RampAsset> | undefined, b: GetAccountInfoResponse_Wallet_RampAsset | PlainMessage<GetAccountInfoResponse_Wallet_RampAsset> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_Wallet_RampAsset, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.Wallet.OnRamp
 */
export class GetAccountInfoResponse_Wallet_OnRamp extends Message<GetAccountInfoResponse_Wallet_OnRamp> {
  /**
   * e.g. "ETU1"
   *
   * @generated from field: string payment_reference = 10;
   */
  paymentReference = "";

  constructor(data?: PartialMessage<GetAccountInfoResponse_Wallet_OnRamp>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.Wallet.OnRamp";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "payment_reference", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_Wallet_OnRamp {
    return new GetAccountInfoResponse_Wallet_OnRamp().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Wallet_OnRamp {
    return new GetAccountInfoResponse_Wallet_OnRamp().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Wallet_OnRamp {
    return new GetAccountInfoResponse_Wallet_OnRamp().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_Wallet_OnRamp | PlainMessage<GetAccountInfoResponse_Wallet_OnRamp> | undefined, b: GetAccountInfoResponse_Wallet_OnRamp | PlainMessage<GetAccountInfoResponse_Wallet_OnRamp> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_Wallet_OnRamp, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.Wallet.OffRamp
 */
export class GetAccountInfoResponse_Wallet_OffRamp extends Message<GetAccountInfoResponse_Wallet_OffRamp> {
  /**
   * address, crypto asset should be send to for offramping
   *
   * @generated from field: string address = 10;
   */
  address = "";

  constructor(data?: PartialMessage<GetAccountInfoResponse_Wallet_OffRamp>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.Wallet.OffRamp";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_Wallet_OffRamp {
    return new GetAccountInfoResponse_Wallet_OffRamp().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Wallet_OffRamp {
    return new GetAccountInfoResponse_Wallet_OffRamp().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Wallet_OffRamp {
    return new GetAccountInfoResponse_Wallet_OffRamp().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_Wallet_OffRamp | PlainMessage<GetAccountInfoResponse_Wallet_OffRamp> | undefined, b: GetAccountInfoResponse_Wallet_OffRamp | PlainMessage<GetAccountInfoResponse_Wallet_OffRamp> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_Wallet_OffRamp, a, b);
  }
}

/**
 * @generated from message ramp.v1.WhitelistAddressRequest
 */
export class WhitelistAddressRequest extends Message<WhitelistAddressRequest> {
  /**
   * user given name, could be same name as in the Self Custody wallet if supported by wallet vendor
   * (the maximum length of the name is 100 symbols)
   *
   * @generated from field: string name = 10;
   */
  name = "";

  /**
   * Ethereum, Avalanche, Terra and etc.
   *
   * @generated from field: ramp.v1.Protocol protocol = 20;
   */
  protocol = Protocol.UNSPECIFIED;

  /**
   * address in particular blockchain e.g. 0x31792BB64B2fA8e0a4F5fD8F82DDf81A6F2C30e0
   *
   * limited to 255 characters
   *
   * @generated from field: string address = 30;
   */
  address = "";

  /**
   * address must be derived from the provided public key
   * public key in particular ecosystem, encoded accordingly to ecosystem rules (Ethereum - hex, Cosmos - base64)
   *
   * limited to 255 characters
   *
   * @generated from field: string public_key = 35;
   */
  publicKey = "";

  /**
   * the address should be signed with its private key
   * for the Ethereum: the address should be signed with https://docs.metamask.io/wallet/reference/personal_sign/
   *
   * @generated from field: string address_signature = 40;
   */
  addressSignature = "";

  constructor(data?: PartialMessage<WhitelistAddressRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.WhitelistAddressRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "protocol", kind: "enum", T: proto3.getEnumType(Protocol) },
    { no: 30, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 35, name: "public_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 40, name: "address_signature", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WhitelistAddressRequest {
    return new WhitelistAddressRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WhitelistAddressRequest {
    return new WhitelistAddressRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WhitelistAddressRequest {
    return new WhitelistAddressRequest().fromJsonString(jsonString, options);
  }

  static equals(a: WhitelistAddressRequest | PlainMessage<WhitelistAddressRequest> | undefined, b: WhitelistAddressRequest | PlainMessage<WhitelistAddressRequest> | undefined): boolean {
    return proto3.util.equals(WhitelistAddressRequest, a, b);
  }
}

/**
 * @generated from message ramp.v1.WhitelistAddressResponse
 */
export class WhitelistAddressResponse extends Message<WhitelistAddressResponse> {
  constructor(data?: PartialMessage<WhitelistAddressResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.WhitelistAddressResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WhitelistAddressResponse {
    return new WhitelistAddressResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WhitelistAddressResponse {
    return new WhitelistAddressResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WhitelistAddressResponse {
    return new WhitelistAddressResponse().fromJsonString(jsonString, options);
  }

  static equals(a: WhitelistAddressResponse | PlainMessage<WhitelistAddressResponse> | undefined, b: WhitelistAddressResponse | PlainMessage<WhitelistAddressResponse> | undefined): boolean {
    return proto3.util.equals(WhitelistAddressResponse, a, b);
  }
}

/**
 * @generated from message ramp.v1.RemoveAddressRequest
 */
export class RemoveAddressRequest extends Message<RemoveAddressRequest> {
  /**
   * @generated from field: ramp.v1.Protocol protocol = 10;
   */
  protocol = Protocol.UNSPECIFIED;

  /**
   * address in particular blockchain e.g. 0x31792BB64B2fA8e0a4F5fD8F82DDf81A6F2C30e0
   *
   * @generated from field: string address = 30;
   */
  address = "";

  constructor(data?: PartialMessage<RemoveAddressRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.RemoveAddressRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "protocol", kind: "enum", T: proto3.getEnumType(Protocol) },
    { no: 30, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RemoveAddressRequest {
    return new RemoveAddressRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RemoveAddressRequest {
    return new RemoveAddressRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RemoveAddressRequest {
    return new RemoveAddressRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RemoveAddressRequest | PlainMessage<RemoveAddressRequest> | undefined, b: RemoveAddressRequest | PlainMessage<RemoveAddressRequest> | undefined): boolean {
    return proto3.util.equals(RemoveAddressRequest, a, b);
  }
}

/**
 * @generated from message ramp.v1.RemoveAddressResponse
 */
export class RemoveAddressResponse extends Message<RemoveAddressResponse> {
  constructor(data?: PartialMessage<RemoveAddressResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.RemoveAddressResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RemoveAddressResponse {
    return new RemoveAddressResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RemoveAddressResponse {
    return new RemoveAddressResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RemoveAddressResponse {
    return new RemoveAddressResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RemoveAddressResponse | PlainMessage<RemoveAddressResponse> | undefined, b: RemoveAddressResponse | PlainMessage<RemoveAddressResponse> | undefined): boolean {
    return proto3.util.equals(RemoveAddressResponse, a, b);
  }
}

/**
 * @generated from message ramp.v1.SetBankAccountRequest
 */
export class SetBankAccountRequest extends Message<SetBankAccountRequest> {
  /**
   * first and last beneficiary name is not required. KYC info will be used as beneficiary name
   *
   * @generated from oneof ramp.v1.SetBankAccountRequest.bank_account
   */
  bankAccount: {
    /**
     * only for scheme SCAN
     *
     * @generated from field: ramp.v1.ScanCoordinates scan = 10;
     */
    value: ScanCoordinates;
    case: "scan";
  } | {
    /**
     * for both SEPA and SWIFT schemes
     *
     * @generated from field: ramp.v1.IbanCoordinates iban = 20;
     */
    value: IbanCoordinates;
    case: "iban";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SetBankAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.SetBankAccountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "scan", kind: "message", T: ScanCoordinates, oneof: "bank_account" },
    { no: 20, name: "iban", kind: "message", T: IbanCoordinates, oneof: "bank_account" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetBankAccountRequest {
    return new SetBankAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetBankAccountRequest {
    return new SetBankAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetBankAccountRequest {
    return new SetBankAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetBankAccountRequest | PlainMessage<SetBankAccountRequest> | undefined, b: SetBankAccountRequest | PlainMessage<SetBankAccountRequest> | undefined): boolean {
    return proto3.util.equals(SetBankAccountRequest, a, b);
  }
}

/**
 * The client should comply to basic validation rules such as min/max length for ibans, sort codes and account numbers
 * complex validation such as IBAN or SCAN checksums and sort code directory is performed by Harbour
 *
 * @generated from message ramp.v1.SetBankAccountResponse
 */
export class SetBankAccountResponse extends Message<SetBankAccountResponse> {
  /**
   * @generated from field: repeated ramp.v1.SetBankAccountResponse.Error errors = 10;
   */
  errors: SetBankAccountResponse_Error[] = [];

  constructor(data?: PartialMessage<SetBankAccountResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.SetBankAccountResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "errors", kind: "enum", T: proto3.getEnumType(SetBankAccountResponse_Error), repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetBankAccountResponse {
    return new SetBankAccountResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetBankAccountResponse {
    return new SetBankAccountResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetBankAccountResponse {
    return new SetBankAccountResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SetBankAccountResponse | PlainMessage<SetBankAccountResponse> | undefined, b: SetBankAccountResponse | PlainMessage<SetBankAccountResponse> | undefined): boolean {
    return proto3.util.equals(SetBankAccountResponse, a, b);
  }
}

/**
 * @generated from enum ramp.v1.SetBankAccountResponse.Error
 */
export enum SetBankAccountResponse_Error {
  /**
   * @generated from enum value: ERROR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Returned when the routing code is wrong (eg: sort code for UK and BIC for ibans).
   * Note: the client still needs to perform basic validation, such as guaranteeing that the sort code is exactly 6 digits,
   * else it won't even get this response and just get a code invalid argument.
   * However, the backend will perform more advanced validation, such as checking that the sort code exists, in which
   * case it will return this error.
   *
   * @generated from enum value: ERROR_BANK_CODE_INVALID = 1;
   */
  BANK_CODE_INVALID = 1,

  /**
   * Same as above, but for the account number (eg: account number for UK and IBAN for ibans).
   * In case of UK account numbers, the account number is validated against the sort code, to determine whether it's
   * valid according to the destination bank.
   * In case of IBAN, basic mathematical checks will be performed, according to the IBAN standard, to verify its validity.
   *
   * @generated from enum value: ERROR_BANK_NUMBER_INVALID = 2;
   */
  BANK_NUMBER_INVALID = 2,

  /**
   * Returned when the user tries to set the bank account same as the magic-ramp account.
   *
   * @generated from enum value: ERROR_SAME_BANK_ACCOUNT = 3;
   */
  SAME_BANK_ACCOUNT = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(SetBankAccountResponse_Error)
proto3.util.setEnumType(SetBankAccountResponse_Error, "ramp.v1.SetBankAccountResponse.Error", [
  { no: 0, name: "ERROR_UNSPECIFIED" },
  { no: 1, name: "ERROR_BANK_CODE_INVALID" },
  { no: 2, name: "ERROR_BANK_NUMBER_INVALID" },
  { no: 3, name: "ERROR_SAME_BANK_ACCOUNT" },
]);

/**
 * @generated from message ramp.v1.EstimateOnRampFeeRequest
 */
export class EstimateOnRampFeeRequest extends Message<EstimateOnRampFeeRequest> {
  /**
   * @generated from field: ramp.v1.AssetId crypto_asset_id = 10;
   */
  cryptoAssetId = AssetId.ASSET_ID_UNSPECIFIED;

  /**
   * @generated from field: ramp.v1.Protocol protocol = 15;
   */
  protocol = Protocol.UNSPECIFIED;

  /**
   * @generated from oneof ramp.v1.EstimateOnRampFeeRequest.amount
   */
  amount: {
    /**
     * string crypto_asset_amount = 30; // TODO:
     *
     * @generated from field: string fiat_asset_amount = 20;
     */
    value: string;
    case: "fiatAssetAmount";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<EstimateOnRampFeeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.EstimateOnRampFeeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "crypto_asset_id", kind: "enum", T: proto3.getEnumType(AssetId) },
    { no: 15, name: "protocol", kind: "enum", T: proto3.getEnumType(Protocol) },
    { no: 20, name: "fiat_asset_amount", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "amount" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EstimateOnRampFeeRequest {
    return new EstimateOnRampFeeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EstimateOnRampFeeRequest {
    return new EstimateOnRampFeeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EstimateOnRampFeeRequest {
    return new EstimateOnRampFeeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: EstimateOnRampFeeRequest | PlainMessage<EstimateOnRampFeeRequest> | undefined, b: EstimateOnRampFeeRequest | PlainMessage<EstimateOnRampFeeRequest> | undefined): boolean {
    return proto3.util.equals(EstimateOnRampFeeRequest, a, b);
  }
}

/**
 * @generated from message ramp.v1.EstimateOnRampFeeResponse
 */
export class EstimateOnRampFeeResponse extends Message<EstimateOnRampFeeResponse> {
  /**
   * denominated in user's fiat currency
   *
   * @generated from field: string fiat_asset_amount = 20;
   */
  fiatAssetAmount = "";

  /**
   * denominated in crypto_asset
   *
   * @generated from field: string crypto_asset_amount = 30;
   */
  cryptoAssetAmount = "";

  /**
   * @generated from field: string exchange_rate = 40;
   */
  exchangeRate = "";

  /**
   * denominated in user's fiat currency
   *
   * @generated from field: string network_fee_amount = 50;
   */
  networkFeeAmount = "";

  /**
   * denominated in user's fiat currency
   *
   * @generated from field: string processing_fee_amount = 60;
   */
  processingFeeAmount = "";

  constructor(data?: PartialMessage<EstimateOnRampFeeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.EstimateOnRampFeeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 20, name: "fiat_asset_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 30, name: "crypto_asset_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 40, name: "exchange_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 50, name: "network_fee_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 60, name: "processing_fee_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EstimateOnRampFeeResponse {
    return new EstimateOnRampFeeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EstimateOnRampFeeResponse {
    return new EstimateOnRampFeeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EstimateOnRampFeeResponse {
    return new EstimateOnRampFeeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: EstimateOnRampFeeResponse | PlainMessage<EstimateOnRampFeeResponse> | undefined, b: EstimateOnRampFeeResponse | PlainMessage<EstimateOnRampFeeResponse> | undefined): boolean {
    return proto3.util.equals(EstimateOnRampFeeResponse, a, b);
  }
}

/**
 * @generated from message ramp.v1.EstimateOffRampFeeRequest
 */
export class EstimateOffRampFeeRequest extends Message<EstimateOffRampFeeRequest> {
  /**
   * @generated from field: ramp.v1.AssetId crypto_asset_id = 10;
   */
  cryptoAssetId = AssetId.ASSET_ID_UNSPECIFIED;

  /**
   * @generated from field: ramp.v1.Protocol protocol = 15;
   */
  protocol = Protocol.UNSPECIFIED;

  /**
   * @generated from oneof ramp.v1.EstimateOffRampFeeRequest.amount
   */
  amount: {
    /**
     * string fiat_asset_amount = 30; // TODO:
     *
     * @generated from field: string crypto_asset_amount = 20;
     */
    value: string;
    case: "cryptoAssetAmount";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<EstimateOffRampFeeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.EstimateOffRampFeeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "crypto_asset_id", kind: "enum", T: proto3.getEnumType(AssetId) },
    { no: 15, name: "protocol", kind: "enum", T: proto3.getEnumType(Protocol) },
    { no: 20, name: "crypto_asset_amount", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "amount" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EstimateOffRampFeeRequest {
    return new EstimateOffRampFeeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EstimateOffRampFeeRequest {
    return new EstimateOffRampFeeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EstimateOffRampFeeRequest {
    return new EstimateOffRampFeeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: EstimateOffRampFeeRequest | PlainMessage<EstimateOffRampFeeRequest> | undefined, b: EstimateOffRampFeeRequest | PlainMessage<EstimateOffRampFeeRequest> | undefined): boolean {
    return proto3.util.equals(EstimateOffRampFeeRequest, a, b);
  }
}

/**
 * @generated from message ramp.v1.EstimateOffRampFeeResponse
 */
export class EstimateOffRampFeeResponse extends Message<EstimateOffRampFeeResponse> {
  /**
   * denominated in user's fiat currency
   *
   * @generated from field: string fiat_asset_amount = 20;
   */
  fiatAssetAmount = "";

  /**
   * denominated in crypto_asset
   *
   * @generated from field: string crypto_asset_amount = 30;
   */
  cryptoAssetAmount = "";

  /**
   * @generated from field: string exchange_rate = 40;
   */
  exchangeRate = "";

  /**
   * denominated in user's fiat currency
   *
   * @generated from field: string processing_fee_amount = 60;
   */
  processingFeeAmount = "";

  constructor(data?: PartialMessage<EstimateOffRampFeeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.EstimateOffRampFeeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 20, name: "fiat_asset_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 30, name: "crypto_asset_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 40, name: "exchange_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 60, name: "processing_fee_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EstimateOffRampFeeResponse {
    return new EstimateOffRampFeeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EstimateOffRampFeeResponse {
    return new EstimateOffRampFeeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EstimateOffRampFeeResponse {
    return new EstimateOffRampFeeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: EstimateOffRampFeeResponse | PlainMessage<EstimateOffRampFeeResponse> | undefined, b: EstimateOffRampFeeResponse | PlainMessage<EstimateOffRampFeeResponse> | undefined): boolean {
    return proto3.util.equals(EstimateOffRampFeeResponse, a, b);
  }
}

/**
 * @generated from message ramp.v1.ScanCoordinates
 */
export class ScanCoordinates extends Message<ScanCoordinates> {
  /**
   * always 8 digits
   *
   * @generated from field: string account_number = 10;
   */
  accountNumber = "";

  /**
   * always 6 digits (if using an input mask such as ##-##-##, remove the dashes before submitting)
   *
   * @generated from field: string sort_code = 20;
   */
  sortCode = "";

  constructor(data?: PartialMessage<ScanCoordinates>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.ScanCoordinates";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "account_number", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "sort_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScanCoordinates {
    return new ScanCoordinates().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScanCoordinates {
    return new ScanCoordinates().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScanCoordinates {
    return new ScanCoordinates().fromJsonString(jsonString, options);
  }

  static equals(a: ScanCoordinates | PlainMessage<ScanCoordinates> | undefined, b: ScanCoordinates | PlainMessage<ScanCoordinates> | undefined): boolean {
    return proto3.util.equals(ScanCoordinates, a, b);
  }
}

/**
 * @generated from message ramp.v1.IbanCoordinates
 */
export class IbanCoordinates extends Message<IbanCoordinates> {
  /**
   * up to 34 characters (please submit them all uppercase) and numbers
   *
   * @generated from field: string iban = 10;
   */
  iban = "";

  constructor(data?: PartialMessage<IbanCoordinates>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.IbanCoordinates";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "iban", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IbanCoordinates {
    return new IbanCoordinates().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IbanCoordinates {
    return new IbanCoordinates().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IbanCoordinates {
    return new IbanCoordinates().fromJsonString(jsonString, options);
  }

  static equals(a: IbanCoordinates | PlainMessage<IbanCoordinates> | undefined, b: IbanCoordinates | PlainMessage<IbanCoordinates> | undefined): boolean {
    return proto3.util.equals(IbanCoordinates, a, b);
  }
}

