syntax = "proto3";

package ramp.v1;

service PingService {
  rpc Ping (PingRequest) returns (PingResponse) {}
}

message PingRequest {
}

message PingResponse {
  string message = 10;
}

service RampService {
  /**
   * Returns account information. If result in the response is of type  authentication then user should be
   * authenticated (onboarded or logged in). Authentication URL is provided in the result.
   */
  rpc GetAccountInfo (GetAccountInfoRequest) returns (GetAccountInfoResponse) {}

  /**
   * Whitelists address. Crypto assets can only be on-ramped to address which belongs to the user. In order to proof address belongs to the
   * user, address need to be signed with private key of this address.
   */
  rpc WhitelistAddress (WhitelistAddressRequest) returns (WhitelistAddressResponse) {}

  /**
   * Removes whitelisted address
   */
  rpc RemoveAddress (RemoveAddressRequest) returns (RemoveAddressResponse) {}

  // Sets a bank account for the off ramp
  rpc SetBankAccount (SetBankAccountRequest) returns (SetBankAccountResponse) {}

  rpc EstimateOnRampFee (EstimateOnRampFeeRequest) returns (EstimateOnRampFeeResponse) {}
  rpc EstimateOffRampFee (EstimateOffRampFeeRequest) returns (EstimateOffRampFeeResponse) {}
}

message GetAccountInfoRequest {}

message GetAccountInfoResponse {
  oneof result {
    // when result is authentication user needs to be onboarded or logged in
    Authentication authentication = 20;
    // when result is account user is logged
    Account account = 30;
  }

  message Authentication {
    // authentication_url should be loaded in the i-frame or browser window in order to log in or onboard user
    string authentication_url = 10;
    // token expiry in seconds, the frontend is expected to close the onboarding view (but the user can come back any time)
    // don't worry about the time skew from api latency, there's a grace period on top of this expiry
    int64 expires_in_sec = 20;
  }

  message Account {
    // list of whitelisted addresses. On-ramping could be done only to whitelisted address
    repeated Wallet wallets = 10;

    // A bank account created by Harbour in the name of the user, where funds can be sent
    oneof onramp_bank_account {
      ScanCoordinates onramp_scan = 100; // only for scheme SCAN (UK payments)
      IbanCoordinates onramp_iban = 110; // for both SEPA and SWIFT schemes
    }

    // A bank account set by the user for off-ramping, see rpc SetBankAccount
    oneof offramp_bank_account {
      ScanCoordinates offramp_scan = 200; // only for scheme SCAN (UK payments)
      IbanCoordinates offramp_iban = 210; // for both SEPA and SWIFT schemes
    }

    string account_holder = 20; // account holder name for on and off-ramping

    // list of supported assets
    repeated CryptoAsset crypto_assets = 30;
  }

  message CryptoAsset {
    Protocol protocol = 5;
    Network network = 10;
    AssetId asset_id = 20; // the client can use this to match an asset with precision and display custom wording / icon, e.g. "USDC"
    string short_name = 30; // to be used as a fallback if the client doesn't recognise the asset_id (eg: out of date proto definitions)

    oneof details {
      EthereumErc20Token ethereum_erc20_token = 40;
      CosmosIcs20Token cosmos_ics20_token = 50;
      SubstratePsp22Token substrate_psp22_token = 60;
    }

    message EthereumErc20Token {
      string token_address = 10; // ERC20 token address
    }
    message CosmosIcs20Token {
      string ibc_address = 10; // IBC token address
    }
    message SubstratePsp22Token {
      string token_address = 10; // Substrate PSP22 token address
    }
  }

  message Wallet {
    string name = 5; // user given name, less then 100 symbols
    Protocol protocol = 10;
    string address = 20; // address of a wallet in blockchain
    repeated RampAsset assets = 30; // assets available for on- and off- ramping

    message RampAsset {
      CryptoAsset asset = 10;
      OnRamp on_ramp = 20;
      OffRamp off_ramp = 30;
    }

    message OnRamp {
      string payment_reference = 10; // e.g. "ETU1"
    }

    message OffRamp {
      string address = 10; // address, crypto asset should be send to for offramping
    }
  }
}

message WhitelistAddressRequest {
  // user given name, could be same name as in the Self Custody wallet if supported by wallet vendor
  // (the maximum length of the name is 100 symbols)
  string name = 10;
  // Ethereum, Avalanche, Terra and etc.
  Protocol protocol = 20;
  // address in particular blockchain e.g. 0x31792BB64B2fA8e0a4F5fD8F82DDf81A6F2C30e0
  string address = 30; // limited to 255 characters
  // address must be derived from the provided public key
  // public key in particular ecosystem, encoded accordingly to ecosystem rules (Ethereum - hex, Cosmos - base64)
  string public_key = 35; // limited to 255 characters
  // the address should be signed with its private key
  // for the Ethereum: the address should be signed with https://docs.metamask.io/wallet/reference/personal_sign/
  string address_signature = 40;
}

message WhitelistAddressResponse {}

message RemoveAddressRequest {
  Protocol protocol = 10;
  // address in particular blockchain e.g. 0x31792BB64B2fA8e0a4F5fD8F82DDf81A6F2C30e0
  string address = 30;
}

message RemoveAddressResponse {}

message SetBankAccountRequest {
  // first and last beneficiary name is not required. KYC info will be used as beneficiary name
  oneof bank_account {
    ScanCoordinates scan = 10; // only for scheme SCAN
    IbanCoordinates iban = 20; // for both SEPA and SWIFT schemes
  }
}

// The client should comply to basic validation rules such as min/max length for ibans, sort codes and account numbers
// complex validation such as IBAN or SCAN checksums and sort code directory is performed by Harbour
message SetBankAccountResponse {
  repeated Error errors = 10;

  enum Error {
    ERROR_UNSPECIFIED = 0;

    // Returned when the routing code is wrong (eg: sort code for UK and BIC for ibans).
    // Note: the client still needs to perform basic validation, such as guaranteeing that the sort code is exactly 6 digits,
    // else it won't even get this response and just get a code invalid argument.
    // However, the backend will perform more advanced validation, such as checking that the sort code exists, in which
    // case it will return this error.
    ERROR_BANK_CODE_INVALID = 1;

    // Same as above, but for the account number (eg: account number for UK and IBAN for ibans).
    // In case of UK account numbers, the account number is validated against the sort code, to determine whether it's
    // valid according to the destination bank.
    // In case of IBAN, basic mathematical checks will be performed, according to the IBAN standard, to verify its validity.
    ERROR_BANK_NUMBER_INVALID = 2;

    // Returned when the user tries to set the bank account same as the magic-ramp account.
    ERROR_SAME_BANK_ACCOUNT = 3;
  }
}

message EstimateOnRampFeeRequest {
  AssetId crypto_asset_id = 10;
  Protocol protocol = 15;
  oneof amount {
    string fiat_asset_amount = 20;
    // string crypto_asset_amount = 30; // TODO:
  }
}

message EstimateOnRampFeeResponse {
  string fiat_asset_amount = 20; // denominated in user's fiat currency
  string crypto_asset_amount = 30; // denominated in crypto_asset
  string exchange_rate = 40;
  string network_fee_amount = 50; // denominated in user's fiat currency
  string processing_fee_amount = 60; // denominated in user's fiat currency
}

message EstimateOffRampFeeRequest {
  AssetId crypto_asset_id = 10;
  Protocol protocol = 15;
  oneof amount {
    string crypto_asset_amount = 20;
    //string fiat_asset_amount = 30; // TODO:
  }
}

message EstimateOffRampFeeResponse {
  string fiat_asset_amount = 20; // denominated in user's fiat currency
  string crypto_asset_amount = 30; // denominated in crypto_asset
  string exchange_rate = 40;
  string processing_fee_amount = 60; // denominated in user's fiat currency
}

message ScanCoordinates {
  string account_number = 10; // always 8 digits
  string sort_code = 20; // always 6 digits (if using an input mask such as ##-##-##, remove the dashes before submitting)
}

message IbanCoordinates {
  string iban = 10; // up to 34 characters (please submit them all uppercase) and numbers
}

enum Ecosystem {
  ECOSYSTEM_UNSPECIFIED = 0;
  ECOSYSTEM_ETHEREUM = 10; // any EVM compatible chain - addresses are expected to be the right-most 160 bits of the keccak256 hash of the public key
  ECOSYSTEM_COSMOS = 20; // any Cosmos ecosystem chain - addresses are expected to be compatible with the Cosmos SDK (such as 160 bit BECH32)
}

enum Protocol {
  PROTOCOL_UNSPECIFIED = 0;
  PROTOCOL_ETHEREUM = 10;
  PROTOCOL_AVAX = 20;
  PROTOCOL_TERRA = 30;
  PROTOCOL_POLYGON = 40;
  PROTOCOL_ALEPH_ZERO = 50;
}

// An AssetId helps the client to identify an exact token and customise the UI.
// The AssetId is universal across all chains, in fact our responses always include the Network, and the AssetID.
// So ASSET_ID_USDC will always be the official Circle USDC on any chain, be that Ethereum, or Avalanche, or Polygon.
enum AssetId {
  ASSET_ID_UNSPECIFIED = 0;
  ASSET_ID_USDC = 10;
  ASSET_ID_AXL_USDC = 20;
  ASSET_ID_1USD = 30;
}

enum Network {
  NETWORK_UNSPECIFIED = 0;
  NETWORK_ETHEREUM_MAINNET = 10;
  NETWORK_ETHEREUM_SEPOLIA = 20;
  NETWORK_AVAX_FUJI = 30;
  NETWORK_AVAX_C_MAINNET = 40;
  NETWORK_TERRA2_MAINNET = 50;
  NETWORK_POLYGON_MAINNET = 60;
  NETWORK_POLYGON_AMOY = 70;
  NETWORK_ALEPH_ZERO_MAINNET = 80;
  NETWORK_ALEPH_ZERO_TESTNET = 90;
}
